"""
    Caches

This module defines the types, structs and core functions required for storing the
quantities obtained from `NQCModels` in a format which can be easily intregated with
`NQCDynamics`.
"""
module Caches

using LinearAlgebra: LinearAlgebra, Hermitian, I, Eigen, tr
using StaticArrays: SMatrix, SVector
using RingPolymerArrays: get_centroid!

using NQCModels: NQCModels, Model, nstates, mobileatoms, dofs, Subsystem, CompositeModel
using NQCModels.AdiabaticModels: AdiabaticModel
using NQCModels.DiabaticModels: DiabaticModel, DiabaticFrictionModel
using NQCModels.FrictionModels: AdiabaticFrictionModel

using NQCDynamics: ndofs

include("friction.jl")
include("large_diabatic.jl")
include("ring_polymer_large_diabatic.jl")

#Definitions of Abstract Cache Structs
"""
    Abstract_Cache{M<:Model}

Top-level type for all caches.

Each concrete cache contains the `Model` and the fields to store the quantities
obtained from the model.
"""
abstract type Abstract_Cache{T, M<:Model} end #type was called AbstractCalculator

"""
    Abstract_ClassicalModel_Cache{T, M<:Union{AdiabaticModel, CompositeModel}} <: Abstract_Cache{T, M}

Type for storing quantities obtained from models defined by an analytic classical potentials. Examples 
include the harmonic potential (AdiabticModels.Harmonic), the morse potential (AdiabticModels.Morse) and
the Darling-Holloway elbow model (AdiabticModels.DarlingHollowayElbow)
"""
abstract type Abstract_ClassicalModel_Cache{T, M<:Union{AdiabaticModel, CompositeModel}} <: Abstract_Cache{T, M} end #type was called AbstractAdiabaticCalculator

"""
    Abstract_QuantumModel_Cache{T, M<:Union{DiabaticFrictionModel, DiabaticModel}} <: Abstract_Cache{T, M}

Type for storing quantities obtained from models defined in terms of large quantum Hamiltonians or quantum Hamiltonians 
for many independent particles. For these models, the Hamiltonians are large enouch that StaticArrays become inefficient.
The key example is the Anderson-Holstein model (DiabaticModels.AndersonHolstein).
"""
abstract type Abstract_LargeQuantumModel_Cache{T, M<:Union{DiabaticFrictionModel, DiabaticModel}} <: Abstract_Cache{T, M} end #type was called AbstractDiabaticCalculator

"""
    Abstract_StaticArray_QuantumModel_Cache{T, M} <: Abstract_QuantumModel_Cache{T, M}

Type for storing quantities obtained from models defined in terms of quantum Hamiltonians for single particles. 
For these systems, the Hamiltonains are defined in terms of small matrices so StaticArrays are used for efficiency. 
Examples include the double well potential model (DiabaticModels.DoubleWell), the spin-boson model (DiabaticModels.SpinBoson)
and the Erpenbeck-Thoss model (DiabaticModel.ErpenbeckThoss)
"""
abstract type Abstract_QuantumModel_Cache{T, M} <: Abstract_LargeQuantumModel_Cache{T, M} end #type was called AbstractStaticDiabaticCalculator

"""
    Abstract_FrictionTensor_Cache{T, M<:Union{AdiabaticFrictionModel, CompositeModel}} <: Abstract_Cache{T, M}

Type for storing quantities obtained from models defined in terms of a friction tensor. Examples include the 
constant friction (FrictionModels.ConstantFriction), random friction (FrictionModels.RandomFriction) and 
composite friction models (FrictionModels.CompositeFrictionModel) - the latter of which exists as a framework for combining a 
friction model with an classical potential energy surface. 
"""
abstract type Abstract_FrictionTensor_Cache{T, M<:Union{AdiabaticFrictionModel, CompositeModel}} <: Abstract_Cache{T, M} end #type was called AbstractFrictionCalculator

"""
   Abstract_CorrelatedQuantumModel_Cache{T, M<:{CorrelatedQuantumModel}} <: Abstract_Cache{T, M}
 
Type for storing quantities obtained from models defined in terms of quantum Hamiltonians that parameterise a collection of 
interacting electrons and therefore cannot be efficiently solved with exact diagonalisation.
"""
abstract type Abstract_CorrelatedQuantumModel_Cache{T, M<:{CorrelatedQuantumModel}} <: Abstract_Cache{T, M} end #type didn't formerly exist

#Definitions for the concrete Subtypes of the above Cache Types

"""
    ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::{AdiabaticModel, CompositeModel}
        potential::DependentField{T,Matrix{T}}
        derivative::DependentField{Matrix{T},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::DependentField{T,Matrix{T}}
    derivative::DependentField{Matrix{T},Matrix{T}}
    stats::Dict{Symbol,Int}
end

"""
    ClassicalModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation
"""
function ClassicalModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    potential = zero(T)
    derivative = zeros(T, ndofs(model), atoms)
    position = fill(NaN, ndofs(model), atoms)

    stats = Dict{Symbol,Int}(
            :potential=>0,
            :derivative=>0,
    )

    return ClassicalModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        stats
    )
end


"""
    RingPolymer_ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::DependentField{Vector{T},Array{T,3}}
        derivative::DependentField{Array{T,3},Array{T,3}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct RingPolymer_ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{T},Array{T,3}}
    derivative::DependentField{Array{T,3},Array{T,3}}
    stats::Dict{Symbol,Int}
end

"""
    RingPolymer_ClassicalModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_ClassicalModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}
    potential = zeros(T, beads)
    derivative = zeros(T, ndofs(model), atoms, beads)
    position = fill(NaN, ndofs(model), atoms, beads)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
    )

    return RingPolymer_ClassicalModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        stats
    )
end


"""
    QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,SMatrix{S,S,T,L}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,SMatrix{S,S,T,L}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,SMatrix{S,S,T,L},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{SMatrix{S,S,T,L}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{SMatrix{S,S,T,L}},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Hermitian{T,SMatrix{S,S,T,L}},Matrix{T}}
    derivative::DependentField{Matrix{Hermitian{T,SMatrix{S,S,T,L}}},Matrix{T}}
    eigen::DependentField{LinearAlgebra.Eigen{T,T,SMatrix{S,S,T,L},SVector{S,T}},Matrix{T}}
    adiabatic_derivative::DependentField{Matrix{SMatrix{S,S,T,L}},Matrix{T}}
    nonadiabatic_coupling::DependentField{Matrix{SMatrix{S,S,T,L}},Matrix{T}}
    stats::Dict{Symbol,Int}
end

"""
    QuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation.
"""
function QuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    n = nstates(model)
    mat = NQCModels.DiabaticModels.matrix_template(model, T)
    vec = NQCModels.DiabaticModels.vector_template(model, T)

    potential = Hermitian(zero(mat))
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    eigen = Eigen(zero(vec), zero(mat) + I)
    adiabatic_derivative = [zero(mat) for _ in CartesianIndices(derivative)]
    nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(derivative)]
    position = fill(NaN, ndofs(model), atoms)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0
    )

    return QuantumModel_Cache{T,M,n,n^2}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        stats
    )
end


"""
    RingPolymer_QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,SMatrix{S,S,T,L}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,SMatrix{S,S,T,L}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,SMatrix{S,S,T,L},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{SMatrix{S,S,T,L}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{SMatrix{S,S,T,L}},Matrix{T}}

        traceless_potential::DependentField{Vector{Hermitian{T,SMatrix{S,S,T,L}}},Array{T,3}}
        V̄::DependentField{Vector{T},Array{T,3}}
        traceless_derivative::DependentField{Array{Hermitian{T,SMatrix{S,S,T,L}},3},Array{T,3}}
        D̄::DependentField{Array{T,3},Array{T,3}}
        traceless_adiabatic_derivative::DependentField{Array{SMatrix{S,S,T,L},3},Array{T,3}}

        centroid::DependentField{Matrix{T},Array{T,3}}
        centroid_potential::DependentField{Hermitian{T,SMatrix{S,S,T,L}},Array{T,3}}
        centroid_derivative::DependentField{Matrix{Hermitian{T,SMatrix{S,S,T,L}}},Array{T,3}}
        centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,SMatrix{S,S,T,L},SVector{S,T}},Array{T,3}}
        centroid_adiabatic_derivative::DependentField{Matrix{SMatrix{S,S,T,L}},Array{T,3}}
        centroid_nonadiabatic_coupling::DependentField{Matrix{SMatrix{S,S,T,L}},Array{T,3}}

        stats::Dict{Symbol,Int}

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct RingPolymer_QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{Hermitian{T,SMatrix{S,S,T,L}}},Array{T,3}}
    derivative::DependentField{Array{Hermitian{T,SMatrix{S,S,T,L}},3},Array{T,3}}
    eigen::DependentField{Vector{LinearAlgebra.Eigen{T,T,SMatrix{S,S,T,L},SVector{S,T}}},Array{T,3}}
    adiabatic_derivative::DependentField{Array{SMatrix{S,S,T,L},3},Array{T,3}}
    nonadiabatic_coupling::DependentField{Array{SMatrix{S,S,T,L},3},Array{T,3}}

    traceless_potential::DependentField{Vector{Hermitian{T,SMatrix{S,S,T,L}}},Array{T,3}}
    V̄::DependentField{Vector{T},Array{T,3}}
    traceless_derivative::DependentField{Array{Hermitian{T,SMatrix{S,S,T,L}},3},Array{T,3}}
    D̄::DependentField{Array{T,3},Array{T,3}}
    traceless_adiabatic_derivative::DependentField{Array{SMatrix{S,S,T,L},3},Array{T,3}}

    centroid::DependentField{Matrix{T},Array{T,3}}
    centroid_potential::DependentField{Hermitian{T,SMatrix{S,S,T,L}},Array{T,3}}
    centroid_derivative::DependentField{Matrix{Hermitian{T,SMatrix{S,S,T,L}}},Array{T,3}}
    centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,SMatrix{S,S,T,L},SVector{S,T}},Array{T,3}}
    centroid_adiabatic_derivative::DependentField{Matrix{SMatrix{S,S,T,L}},Array{T,3}}
    centroid_nonadiabatic_coupling::DependentField{Matrix{SMatrix{S,S,T,L}},Array{T,3}}

    stats::Dict{Symbol,Int}
end

"""
    RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}
    n = nstates(model)
    mat = NQCModels.DiabaticModels.matrix_template(model, T)
    vec = NQCModels.DiabaticModels.vector_template(model, T)

    potential = [Hermitian(zero(mat)) for _=1:beads]
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    eigen = [Eigen(zero(vec), zero(mat) + I) for _=1:beads]
    nonadiabatic_coupling = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]

    traceless_potential = [Hermitian(zero(mat)) for _=1:beads]
    V̄ = zeros(beads)
    traceless_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    D̄ = zeros(ndofs(model), atoms, beads)
    traceless_adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = Hermitian(zero(mat))
    centroid_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    centroid_eigen = Eigen(zero(vec), zero(mat) + I)
    centroid_adiabatic_derivative = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(centroid_derivative)]

    position = fill(NaN, ndofs(model), atoms, beads)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0,
        :traceless_potential=>0,
        :V̄=>0,
        :traceless_derivative=>0,
        :D̄=>0,
        :traceless_adiabatic_derivative=>0,
        :centroid=>0,
        :centroid_potential=>0,
        :centroid_derivative=>0,
        :centroid_eigen=>0,
        :centroid_adiabatic_derivative=>0,
        :centroid_nonadiabatic_coupling=>0,
    )

    return RingPolymer_StaticArray_QuantumModel_Cache{T,M,n,n^2}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),

        DependentField(traceless_potential, copy(position)),
        DependentField(V̄, copy(position)),
        DependentField(traceless_derivative, copy(position)),
        DependentField(D̄, copy(position)),
        DependentField(traceless_adiabatic_derivative, copy(position)),

        DependentField(centroid, copy(position)),
        DependentField(centroid_potential, copy(position)),
        DependentField(centroid_derivative, copy(position)),
        DependentField(centroid_eigen, copy(position)),
        DependentField(centroid_adiabatic_derivative, copy(position)),
        DependentField(centroid_nonadiabatic_coupling, copy(position)),
        stats
    )
end

#Definitions of the Create_Cache function with creates a Cache of the appropriate type dependent on what model type it is given
function Create_Cache(model::AdiabaticModel, atoms::Integer, t::Type{T}) where {T}  #functions of this type were called Calculator(model, atoms, t)
    ClassicalModel_Cache{t}(model, atoms)
end

function Create_Cache(model::AdiabaticModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_ClassicalModel_Cache{t}(model, atoms, beads)
end

function Create_Cache(model::DiabaticModel, atoms::Integer, t::Type{T}) where {T}
    QuantumModel_Cache{t}(model, atoms)
end

function Create_Cache(model::DiabaticModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_QuantumModel_Cache{t}(model, atoms, beads)
end

#Definitions of standard NQCModels functions on an Abstract Cache.
NQCModels.nstates(cache::Abstract_Cache) = NQCModels.nstates(cache.model)
NQCModels.eachstate(cache::Abstract_Cache) = NQCModels.eachstate(cache.model)
NQCModels.nelectrons(cache::Abstract_Cache) = NQCModels.nelectrons(cache.model)
NQCModels.eachelectron(cache::Abstract_Cache) = NQCModels.eachelectron(cache.model)
NQCModels.mobileatoms(cache::Abstract_Cache) = NQCModels.mobileatoms(cache.model, size(cache.derivative, 2))
NQCModels.dofs(cache::Abstract_Cache) = NQCModels.dofs(cache.model)
NQCModels.fermilevel(cache::Abstract_Cache) = NQCModels.fermilevel(cache.model)
beads(cache) = Base.OneTo(length(cache.potential))
Base.eltype(::Abstract_Cache{T}) where {T} = T

end # module