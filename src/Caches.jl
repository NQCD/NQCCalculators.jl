#Definitions of Abstract Cache structs
"""
    type: Abstract_Cache{M<:Model}

Top-level type for all caches.

Each concrete cache contains the `Model` and the fields to store the quantities
obtained from the model.
"""
abstract type Abstract_Cache{T, M<:Model} end #type was called AbstractCalculator

"""
    type: Abstract_ClassicalModel_Cache{T, M<:Union{ClassicalModel, CompositeModel}} <: Abstract_Cache{T, M}

Type for storing quantities obtained from models defined by an analytic classical potentials. Examples 
include the harmonic potential (AdiabticModels.Harmonic), the morse potential (AdiabticModels.Morse) and
the Darling-Holloway elbow model (AdiabticModels.DarlingHollowayElbow)
"""
abstract type Abstract_ClassicalModel_Cache{T, M<:Union{ClassicalModel, ClassicalFrictionModel, CompositeModel}} <: Abstract_Cache{T, M} end #type was called AbstractAdiabaticCalculator

"""
    type: Abstract_QuantumModel_Cache{T, M} <: Abstract_Cache{T, M}

Abstract supertype for all quantum models that can be solved with exact diagonalisation.
"""
abstract type Abstract_QuantumModel_Cache{T, M<:Union{QuantumModel, QuantumFrictionModel}} <: Abstract_Cache{T, M} end #type was called AbstractDiabaticCalculator

"""
   type: Abstract_CorrelatedQuantumModel_Cache{T, M<:{CorrelatedQuantumModel}} <: Abstract_Cache{T, M}
 
Type for storing quantities obtained from models defined in terms of quantum Hamiltonians that parameterise a collection of 
interacting electrons and therefore cannot be solved with exact diagonalisation.
"""
abstract type Abstract_CorrelatedQuantumModel_Cache{T, M} <: Abstract_QuantumModel_Cache{T, M} end #type didn't formerly exist



#Definitions for the concrete Subtypes of the above Cache Types
"""
    struct: ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::{ClassicalModel, CompositeModel}
        potential::T,Matrix{T}}
        derivative::Matrix{T},Matrix{T}}
        

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::Matrix{T}
    derivative::Matrix{T}
    
end

"""
    function: ClassicalModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation
"""
function ClassicalModel_Cache(model::M, atoms::Integer, T::Type) where {M<:Model}
    potential = hcat(zero(T))
    derivative = zeros(T, ndofs(model), atoms)

    return ClassicalModel_Cache{T,M}(
        model,
        potential,
        derivative
    )
end


"""
    struct: RingPolymer_ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::Vector{Matrix{T}}
        derivative::Array{T,3}
    
        centroid::Matrix{T}
        centroid_potential::Hermitian{T,Matrix{T}}
        centroid_derivative::Matrix{Hermitian{T,Matrix{T}}}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct RingPolymer_ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::Vector{Matrix{T}}
    derivative::Array{T,3}

    centroid::Matrix{T}
    centroid_potential::Matrix{T}
    centroid_derivative::Matrix{T}
    
end

"""
    function: RingPolymer_ClassicalModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_ClassicalModel_Cache(model::M, atoms::Integer, beads::Integer, T::Type) where {M<:Model}
    potential = [hcat(zero(T)) for i in 1:beads]
    derivative = zeros(T, ndofs(model), atoms, beads)

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = hcat(zero(T))
    centroid_derivative = zeros(T, ndofs(model), atoms)

    return RingPolymer_ClassicalModel_Cache{T,M}(
        model,
        potential,
        derivative,

        centroid,
        centroid_potential,
        centroid_derivative
    )
end

"""
    struct: ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::Matrix{T}
        derivative::Matrix{T},Matrix{T}}
        friction::Matrix{T},Matrix{T}}
        

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M} #was mutable struct - changed for efficiency, needs testing to determine if this is a code breaking change
    model::M
    potential::Matrix{T}
    derivative::Matrix{T}
    friction::Matrix{T}
    
end

"""
    function: ClassicalFrictionModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the struct of the same name. Takes as input an adiabatic friction model `M` of the users choice and 
the number of atoms in the simulation.
"""
function ClassicalFrictionModel_Cache(model::M, atoms::Integer, T::Type) where {M<:Model}
    potential = hcat(zero(T))
    derivative = zeros(ndofs(model), atoms)
    friction = zeros(ndofs(model)*atoms, ndofs(model)*atoms)

    return ClassicalFrictionModel_Cache{T,M}(
        model,
        potential,
        derivative,
        friction
    )
end


"""
    struct: RingPolymer_ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::Vector{Matrix{T}}
        derivative::Matrix{T}
        friction::Matrix{T}

        centroid::Matrix{T}
        centroid_potential::Hermitian{T,Matrix{T}}
        centroid_derivative::Matrix{Hermitian{T,Matrix{T}}}
        centroid_eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        centroid_adiabatic_derivative::Matrix{Matrix{T}}
        centroid_nonadiabatic_coupling::Matrix{Matrix{T}}
        

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct RingPolymer_ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::Vector{Matrix{T}}
    derivative::Array{T,3}
    friction::Array{T,3}

    centroid::Matrix{T}
    centroid_potential::Matrix{T}
    centroid_derivative::Matrix{T}
    centroid_friction::Matrix{T} 
end

"""
    function: RingPolymer_ClassicalFrictionModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_ClassicalFrictionModel_Cache(model::M, atoms::Integer, beads::Integer, T::Type) where {M<:Model}

    potential = fill(hcat(zero(T)), beads)
    derivative = zeros(T, ndofs(model), atoms, beads)
    friction = zeros(T, ndofs(model)*atoms, ndofs(model)*atoms, beads)

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = hcat(zero(T))
    centroid_derivative = zeros(T, ndofs(model), atoms)
    centroid_friction = zeros(T, ndofs(model)*atoms, ndofs(model)*atoms)

    return RingPolymer_ClassicalFrictionModel_Cache{T,M}(
        model,
        potential,
        derivative,
        friction,

        centroid,
        centroid_potential,
        centroid_derivative,
        centroid_friction
    )
end

"""
    struct: QuantumModel_Cache{T,M} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::Hermitian{T,Matrix{T}}
        derivative::Matrix{Hermitian{T,Matrix{T}}}
        eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        adiabatic_derivative::Matrix{Matrix{T}}
        nonadiabatic_coupling::Matrix{Matrix{T}}
        

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct QuantumModel_Cache{T,M} <: Abstract_QuantumModel_Cache{T, M}
    model::M
    potential::Hermitian{T,Matrix{T}}
    derivative::Matrix{Hermitian{T,Matrix{T}}}
    eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
    adiabatic_derivative::Matrix{Matrix{T}}
    nonadiabatic_coupling::Matrix{Matrix{T}}
    tmp_mat::Matrix{T}
    
end

"""
    function: QuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation.
"""
function QuantumModel_Cache(model::M, atoms::Integer, T::Type) where {M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = Hermitian(zero(mat))
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    eigen = Eigen(zero(vec), zero(mat) + I)
    adiabatic_derivative = [zero(mat) for _ in CartesianIndices(derivative)]
    nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(derivative)]
    tmp_mat = zero(mat)

    position = zeros(ndofs(model), atoms)

    return QuantumModel_Cache{T,M}(
        model,
        potential,
        derivative,
        eigen,
        adiabatic_derivative,
        nonadiabatic_coupling,
        tmp_mat
    )
end


"""
    struct: RingPolymer_QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::Hermitian{T,Matrix{T}}
        derivative::Matrix{Hermitian{T,Matrix{T}}}
        eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        adiabatic_derivative::Matrix{Matrix{T}}
        nonadiabatic_coupling::Matrix{Matrix{T}}

        traceless_potential::Vector{Hermitian{T,Matrix{T}}}
        V̄::Vector{T}
        traceless_derivative::Array{Hermitian{T,Matrix{T}},3}
        D̄::Array{T,3}
        traceless_adiabatic_derivative::Array{Matrix{T},3}

        centroid::Matrix{T}
        centroid_potential::Hermitian{T,Matrix{T}}
        centroid_derivative::Matrix{Hermitian{T,Matrix{T}}}
        centroid_eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        centroid_adiabatic_derivative::Matrix{Matrix{T}}
        centroid_nonadiabatic_coupling::Matrix{Matrix{T}}

        

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct RingPolymer_QuantumModel_Cache{T, M} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::Vector{Hermitian{T,Matrix{T}}}
    derivative::Array{Hermitian{T,Matrix{T}},3}
    eigen::Vector{LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}}
    adiabatic_derivative::Array{Matrix{T},3}
    nonadiabatic_coupling::Array{Matrix{T},3}
    tmp_mat::Matrix{T}

    traceless_potential::Vector{Hermitian{T,Matrix{T}}}
    V̄::Vector{T}
    traceless_derivative::Array{Hermitian{T,Matrix{T}},3}
    D̄::Array{T,3}
    traceless_adiabatic_derivative::Array{Matrix{T},3}

    centroid::Matrix{T}
    centroid_potential::Hermitian{T,Matrix{T}}
    centroid_derivative::Matrix{Hermitian{T,Matrix{T}}}
    centroid_eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
    centroid_adiabatic_derivative::Matrix{Matrix{T}}
    centroid_nonadiabatic_coupling::Matrix{Matrix{T}}
end

"""
    function: RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_QuantumModel_Cache(model::M, atoms::Integer, beads::Integer, T::Type) where {M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = [Hermitian(zero(mat)) for _=1:beads]
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    eigen = [Eigen(zero(vec), zero(mat) + I) for _=1:beads]
    nonadiabatic_coupling = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    tmp_mat = zero(mat)

    traceless_potential = [Hermitian(zero(mat)) for _=1:beads]
    V̄ = zeros(beads)
    traceless_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    D̄ = zeros(ndofs(model), atoms, beads)
    traceless_adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = Hermitian(zero(mat))
    centroid_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    centroid_eigen = Eigen(zero(vec), zero(mat) + I)
    centroid_adiabatic_derivative = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(centroid_derivative)]

    position = zeros(ndofs(model), atoms, beads)

    return RingPolymer_QuantumModel_Cache{T,M}(
        model,
        potential,
        derivative,
        eigen,
        adiabatic_derivative,
        nonadiabatic_coupling,
        tmp_mat,

        traceless_potential,
        V̄,
        traceless_derivative,
        D̄,
        traceless_adiabatic_derivative,

        centroid,
        centroid_potential,
        centroid_derivative,
        centroid_eigen,
        centroid_adiabatic_derivative,
        centroid_nonadiabatic_coupling
    )
end



"""
    struct: QuantumFrictionModel_Cache{T,M} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::Hermitian{T,Matrix{T}}
        derivative::Matrix{Hermitian{T,Matrix{T}}}
        eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        adiabatic_derivative::Matrix{Matrix{T}}
        nonadiabatic_coupling::Matrix{Matrix{T}}
        

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct QuantumFrictionModel_Cache{T,M} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    friction_method::Union{FrictionEvaluationMethod, Nothing}
    potential::Hermitian{T,Matrix{T}}
    derivative::Matrix{Hermitian{T,Matrix{T}}}
    eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
    adiabatic_derivative::Matrix{Matrix{T}}
    nonadiabatic_coupling::Matrix{Matrix{T}}
    friction::Matrix{T}
    tmp_mat::Matrix{T}
end

"""
    function: QuantumFrictionModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation.
"""
function QuantumFrictionModel_Cache(model::M, atoms::Integer, T::Type; friction_method::Union{FrictionEvaluationMethod, Nothing}) where {M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = Hermitian(zero(mat))
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    eigen = Eigen(zero(vec), zero(mat) + I)
    adiabatic_derivative = [zero(mat) for _ in CartesianIndices(derivative)]
    nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(derivative)]
    friction = zeros(ndofs(model)*atoms, ndofs(model)*atoms)
    tmp_mat = zero(mat)

    if friction_method isa Nothing
        @warn "No friction evaluation algorithm has been specified, the friction tensor will be empty"
    end

    return QuantumFrictionModel_Cache{T,M}(
        model,
        friction_method,
        potential,
        derivative,
        eigen,
        adiabatic_derivative,
        nonadiabatic_coupling,
        friction,
        tmp_mat
    )
end



"""
    struct: RingPolymer_QuantumFrictionModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::Hermitian{T,Matrix{T}}
        derivative::Matrix{Hermitian{T,Matrix{T}}}
        eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        adiabatic_derivative::Matrix{Matrix{T}}
        nonadiabatic_coupling::Matrix{Matrix{T}}

        traceless_potential::Vector{Hermitian{T,Matrix{T}}}
        V̄::Vector{T}
        traceless_derivative::Array{Hermitian{T,Matrix{T}},3}
        D̄::Array{T,3}
        traceless_adiabatic_derivative::Array{Matrix{T},3}

        centroid::Matrix{T}
        centroid_potential::Hermitian{T,Matrix{T}}
        centroid_derivative::Matrix{Hermitian{T,Matrix{T}}}
        centroid_eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
        centroid_adiabatic_derivative::Matrix{Matrix{T}}
        centroid_nonadiabatic_coupling::Matrix{Matrix{T}}

        

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct RingPolymer_QuantumFrictionModel_Cache{T,M} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    friction_method::Union{FrictionEvaluationMethod, Nothing}
    potential::Vector{Hermitian{T,Matrix{T}}}
    derivative::Array{Hermitian{T,Matrix{T}},3}
    eigen::Vector{LinearAlgebra.Eigen{T,T,Matrix{T}, Vector{T}}}
    adiabatic_derivative::Array{Matrix{T},3}
    nonadiabatic_coupling::Array{Matrix{T},3}
    friction::Array{Matrix{T},3}
    tmp_mat::Matrix{T}

    traceless_potential::Vector{Hermitian{T,Matrix{T}}}
    V̄::Vector{T}
    traceless_derivative::Array{Hermitian{T,Matrix{T}},3}
    D̄::Array{T,3}
    traceless_adiabatic_derivative::Array{Matrix{T},3}

    centroid::Matrix{T}
    centroid_potential::Hermitian{T,Matrix{T}}
    centroid_derivative::Matrix{Hermitian{T,Matrix{T}}}
    centroid_eigen::LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}
    centroid_adiabatic_derivative::Matrix{Matrix{T}}
    centroid_nonadiabatic_coupling::Matrix{Matrix{T}}
    centroid_friction::Matrix{T}
end

"""
    function: RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_QuantumFrictionModel_Cache(model::M, atoms::Integer, beads::Integer, T::Type; friction_method::Union{FrictionEvaluationMethod, Nothing}) where {M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = [Hermitian(zero(mat)) for _=1:beads]
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    eigen = [Eigen(zero(vec), zero(mat) + I) for _=1:beads]
    nonadiabatic_coupling = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    friction = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    tmp_mat = zero(mat)

    traceless_potential = [Hermitian(zero(mat)) for _=1:beads]
    V̄ = zeros(beads)
    traceless_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    D̄ = zeros(ndofs(model), atoms, beads)
    traceless_adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = Hermitian(zero(mat))
    centroid_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    centroid_eigen = Eigen(zero(vec), zero(mat) + I)
    centroid_adiabatic_derivative = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_friction = zeros(ndofs(model)*atoms, ndofs(model)*atoms)

    if friction_method isa Nothing
        @warn "No friction evaluation algorithm has been specified, the friction tensor will be empty"
    end

    return RingPolymer_QuantumFrictionModel_Cache{T,M}(
        model,
        friction_method,
        potential,
        derivative,
        eigen,
        adiabatic_derivative,
        nonadiabatic_coupling,
        friction,
        tmp_mat,

        traceless_potential,
        V̄,
        traceless_derivative,
        D̄,
        traceless_adiabatic_derivative,

        centroid,
        centroid_potential,
        centroid_derivative,
        centroid_eigen,
        centroid_adiabatic_derivative,
        centroid_nonadiabatic_coupling,
        centroid_friction
    )
end


#Multiple dispatch definitions of the Create_Cache function with creates a Cache of the appropriate type dependent on what model type it is given
function Create_Cache(model::ClassicalModel, atoms::Integer, t::Type{T}) where {T}  #functions of this type were called Calculator(model, atoms, t)
    ClassicalModel_Cache(model, atoms, t)
end

function Create_Cache(model::ClassicalModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_ClassicalModel_Cache(model, atoms, beads, t)
end

function Create_Cache(model::ClassicalFrictionModel, atoms::Integer, t::Type{T}) where {T}
    ClassicalFrictionModel_Cache(model, atoms, t)
end

function Create_Cache(model::ClassicalFrictionModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_ClassicalFrictionModel_Cache(model, atoms, beads, t)
end

function Create_Cache(model::CompositeModel, atoms::Integer, t::Type{T}) where {T}
    if any([!isa(s.model, ClassicalModel) for s in NQCModels.get_pes_models(model.subsystems)])
        throw(ArgumentError("Currently, only CompositeModels using ClassicalModels to supply a PES are supported. "))
    end
    ClassicalFrictionModel_Cache(model, atoms, t)
end

function Create_Cache(model::CompositeModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    if any([!isa(s.model, ClassicalModel) for s in NQCModels.get_pes_models(model.subsystems)])
        throw(ArgumentError("Currently, only CompositeModels using ClassicalModels to supply a PES are supported. "))
    end
    RingPolymer_ClassicalFrictionModel_Cache(model, atoms, beads, t)
end

function Create_Cache(model::QuantumModel, atoms::Integer, t::Type{T}) where {T}
    QuantumModel_Cache(model, atoms, t)
end

function Create_Cache(model::QuantumModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_QuantumModel_Cache(model, atoms, beads, t)
end

# specific multiple dispatch for AndersonHolstein to work with DiabaticMDEF, friction_methods needs to not be a keyword argument
function Create_Cache(model::QuantumModel, atoms::Integer, t::Type{T}, friction_method::Union{FrictionEvaluationMethod, Nothing}) where {T}
    QuantumFrictionModel_Cache(model, atoms, t; friction_method=friction_method)
end

function Create_Cache(model::QuantumFrictionModel, atoms::Integer, t::Type{T}; friction_method::Union{FrictionEvaluationMethod, Nothing}=nothing) where {T}
    QuantumFrictionModel_Cache(model, atoms, t; friction_method=friction_method)
end

function Create_Cache(model::QuantumFrictionModel, atoms::Integer, beads::Integer, t::Type{T}; friction_method::Union{FrictionEvaluationMethod, Nothing}=nothing) where {T}
    RingPolymer_QuantumFrictionModel_Cache(model, atoms, beads, t; friction_method=friction_method)
end



