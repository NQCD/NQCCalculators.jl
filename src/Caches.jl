#Definitions of Abstract Cache structs
"""
    type: Abstract_Cache{M<:Model}

Top-level type for all caches.

Each concrete cache contains the `Model` and the fields to store the quantities
obtained from the model.
"""
abstract type Abstract_Cache{T, M<:Model} end #type was called AbstractCalculator

"""
    type: Abstract_ClassicalModel_Cache{T, M<:Union{ClassicalModel, CompositeModel}} <: Abstract_Cache{T, M}

Type for storing quantities obtained from models defined by an analytic classical potentials. Examples 
include the harmonic potential (AdiabticModels.Harmonic), the morse potential (AdiabticModels.Morse) and
the Darling-Holloway elbow model (AdiabticModels.DarlingHollowayElbow)
"""
abstract type Abstract_ClassicalModel_Cache{T, M<:Union{ClassicalModel, ClassicalFrictionModel, CompositeModel}} <: Abstract_Cache{T, M} end #type was called AbstractAdiabaticCalculator

"""
    type: Abstract_QuantumModel_Cache{T, M} <: Abstract_Cache{T, M}

Abstract supertype for all quantum models that can be solved with exact diagonalisation.
"""
abstract type Abstract_QuantumModel_Cache{T, M<:Union{QuantumModel, QuantumFrictionModel}} <: Abstract_Cache{T, M} end #type was called AbstractDiabaticCalculator

"""
   type: Abstract_CorrelatedQuantumModel_Cache{T, M<:{CorrelatedQuantumModel}} <: Abstract_Cache{T, M}
 
Type for storing quantities obtained from models defined in terms of quantum Hamiltonians that parameterise a collection of 
interacting electrons and therefore cannot be solved with exact diagonalisation.
"""
abstract type Abstract_CorrelatedQuantumModel_Cache{T, M} <: Abstract_QuantumModel_Cache{T, M} end #type didn't formerly exist

#= 
"""
    type: Abstract_Friction_Cache{T, M<:Union{ClassicalFrictionModel, CompositeModel}} <: Abstract_Cache{T, M}

Type for storing quantities obtained from models defined in terms of a friction tensor. Examples include the 
constant friction (FrictionModels.ConstantFriction), random friction (FrictionModels.RandomFriction) and 
composite friction models (FrictionModels.CompositeFrictionModel) - the latter of which exists as a framework for combining a 
friction model with an classical potential energy surface. 
"""
abstract type Abstract_Friction_Cache{T, M<:Union{ClassicalFrictionModel, CompositeModel}} <: Abstract_Cache{T, M} end #type was called AbstractFrictionCalculator

"""
    type: Abstract_SmallQuantumModel_Cache{T, M} <: Abstract_ExactQuantumModel_Cache{T, M}

Type for storing quantities obtained from models defined in terms of quantum Hamiltonians for single particles. 
For these systems, the Hamiltonains are defined in terms of small matrices so StaticArrays are used for efficiency. 
Examples include the double well potential model (QuantumModels.DoubleWell), the spin-boson model (QuantumModels.SpinBoson)
and the Erpenbeck-Thoss model (QuantumModel.ErpenbeckThoss)
"""
abstract type Abstract_SmallQuantumModel_Cache{T, M} <: Abstract_ExactQuantumModel_Cache{T, M} end #type was called AbstractStaticDiabaticCalculator

"""
    type: Abstract_LargeQuantumModel_Cache{T, M<:Union{QuantumFrictionModel, QuantumModel}} <: Abstract_ExactQuantumModel_Cache{T, M}

Type for storing quantities obtained from models defined in terms of large single particle quantum Hamiltonians or quantum Hamiltonians 
for many independent particles. For these models, the Hamiltonians are large enough that StaticArrays become inefficient.
The key example is the Anderson-Holstein model (QuantumModels.AndersonHolstein).
"""
abstract type Abstract_LargeQuantumModel_Cache{T, M} <: Abstract_ExactQuantumModel_Cache{T, M} end #type was called AbstractLargeDiabaticCalculator
=#

"""
    mutable struct: DependentField{V,R}
        value::V
        position::R

A general use mutable struct used to store cached values that must be updated during a dynamics simulation.
"""
mutable struct DependentField{V,R}
    value::V
    position::R
end

"""
    function: needsupdate(field::DependentField, r)

Function to test if the value stored in the DependentField mutable struct needs to be updated at the given time-step in a dynamics simulation
"""
needsupdate(field::DependentField, r) = field.position != r


#Definitions for the concrete Subtypes of the above Cache Types
"""
    struct: ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::{ClassicalModel, CompositeModel}
        potential::DependentField{T,Matrix{T}}
        derivative::DependentField{Matrix{T},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::DependentField{T,Matrix{T}}
    derivative::DependentField{Matrix{T},Matrix{T}}
    stats::Dict{Symbol,Int}
end

"""
    function: ClassicalModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation
"""
function ClassicalModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    potential = zero(T)
    derivative = zeros(T, ndofs(model), atoms)
    position = fill(NaN, ndofs(model), atoms)

    stats = Dict{Symbol,Int}(
            :potential=>0,
            :derivative=>0,
    )

    return ClassicalModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        stats
    )
end


"""
    struct: RingPolymer_ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::DependentField{Vector{T},Array{T,3}}
        derivative::DependentField{Array{T,3},Array{T,3}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct RingPolymer_ClassicalModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{T},Array{T,3}}
    derivative::DependentField{Array{T,3},Array{T,3}}
    stats::Dict{Symbol,Int}
end

"""
    function: RingPolymer_ClassicalModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_ClassicalModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}
    potential = zeros(T, beads)
    derivative = zeros(T, ndofs(model), atoms, beads)
    position = fill(NaN, ndofs(model), atoms, beads)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
    )

    return RingPolymer_ClassicalModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        stats
    )
end

"""
    struct: ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::DependentField{T,Matrix{T}}
        derivative::DependentField{Matrix{T},Matrix{T}}
        friction::DependentField{Matrix{T},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M} #was mutable struct - changed for efficiency, needs testing to determine if this is a code breaking change
    model::M
    potential::DependentField{T,Matrix{T}}
    derivative::DependentField{Matrix{T},Matrix{T}}
    friction::DependentField{Matrix{T},Matrix{T}}
    stats::Dict{Symbol,Int}
end

"""
    function: ClassicalFrictionModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the struct of the same name. Takes as input an adiabatic friction model `M` of the users choice and 
the number of atoms in the simulation.
"""
function ClassicalFrictionModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    potential = zero(T)
    derivative = zeros(ndofs(model), atoms)
    friction = zeros(ndofs(model)*atoms, ndofs(model)*atoms)

    position = fill(NaN, ndofs(model), atoms)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :friction=>0,
    )

    return ClassicalFrictionModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(friction, copy(position)),
        stats
    )
end


"""
    struct: RingPolymer_ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
        model::M
        potential::DependentField{T,Matrix{T}}
        derivative::DependentField{Matrix{T},Matrix{T}}
        friction::DependentField{Matrix{T},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_ClassicalModel_Cache, used to store quantities (of data type `T`) generated by its input model `M`.
"""
struct RingPolymer_ClassicalFrictionModel_Cache{T,M} <: Abstract_ClassicalModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{T},Array{T,3}}
    derivative::DependentField{Array{T,3},Array{T,3}}
    friction::DependentField{Array{T,3},Array{T,3}}
    stats::Dict{Symbol,Int}
end

"""
    function: RingPolymer_ClassicalFrictionModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_ClassicalFrictionModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

    potential = zeros(beads)
    derivative = zeros(ndofs(model), atoms, beads)
    friction = zeros(ndofs(model)*atoms, ndofs(model)*atoms, beads)

    position = fill(NaN, ndofs(model), atoms, beads)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :friction=>0,
    )

    return RingPolymer_ClassicalFrictionModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(friction, copy(position)),
        stats
    )
end

"""
    struct: QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
    derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
    eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
    adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
    nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}
    tmp_mat::Matrix{T}
    stats::Dict{Symbol,Int}
end

"""
    function: QuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation.
"""
function QuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = Hermitian(zero(mat))
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    eigen = Eigen(zero(vec), zero(mat) + I)
    adiabatic_derivative = [zero(mat) for _ in CartesianIndices(derivative)]
    nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(derivative)]
    tmp_mat = zero(mat)

    position = fill(NaN, ndofs(model), atoms)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0
    )

    return QuantumModel_Cache{T,M,n,n^2}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        tmp_mat,
        stats
    )
end


"""
    struct: RingPolymer_QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}

        traceless_potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
        V̄::DependentField{Vector{T},Array{T,3}}
        traceless_derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
        D̄::DependentField{Array{T,3},Array{T,3}}
        traceless_adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}

        centroid::DependentField{Matrix{T},Array{T,3}}
        centroid_potential::DependentField{Hermitian{T,Matrix{T}},Array{T,3}}
        centroid_derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Array{T,3}}
        centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Array{T,3}}
        centroid_adiabatic_derivative::DependentField{Matrix{Matrix{T}},Array{T,3}}
        centroid_nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Array{T,3}}

        stats::Dict{Symbol,Int}

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct RingPolymer_QuantumModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
    derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
    eigen::DependentField{Vector{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}}},Array{T,3}}
    adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}
    nonadiabatic_coupling::DependentField{Array{Matrix{T},3},Array{T,3}}
    tmp_mat::Matrix{T}

    traceless_potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
    V̄::DependentField{Vector{T},Array{T,3}}
    traceless_derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
    D̄::DependentField{Array{T,3},Array{T,3}}
    traceless_adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}

    centroid::DependentField{Matrix{T},Array{T,3}}
    centroid_potential::DependentField{Hermitian{T,Matrix{T}},Array{T,3}}
    centroid_derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Array{T,3}}
    centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Array{T,3}}
    centroid_adiabatic_derivative::DependentField{Matrix{Matrix{T}},Array{T,3}}
    centroid_nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Array{T,3}}

    stats::Dict{Symbol,Int}
end

"""
    function: RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = [Hermitian(zero(mat)) for _=1:beads]
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    eigen = [Eigen(zero(vec), zero(mat) + I) for _=1:beads]
    nonadiabatic_coupling = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    tmp_mat = zero(mat)

    traceless_potential = [Hermitian(zero(mat)) for _=1:beads]
    V̄ = zeros(beads)
    traceless_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    D̄ = zeros(ndofs(model), atoms, beads)
    traceless_adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = Hermitian(zero(mat))
    centroid_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    centroid_eigen = Eigen(zero(vec), zero(mat) + I)
    centroid_adiabatic_derivative = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(centroid_derivative)]

    position = fill(NaN, ndofs(model), atoms, beads)
FrictionModel
    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0,
        :traceless_potential=>0,
        :V̄=>0,
        :traceless_derivative=>0,
        :D̄=>0,
        :traceless_adiabatic_derivative=>0,
        :centroid=>0,
        :centroid_potential=>0,
        :centroid_derivative=>0,
        :centroid_eigen=>0,
        :centroid_adiabatic_derivative=>0,
        :centroid_nonadiabatic_coupling=>0,
    )

    return RingPolymer_QuantumModel_Cache{T,M,n,n^2}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        tmp_mat,

        DependentField(traceless_potential, copy(position)),
        DependentField(V̄, copy(position)),
        DependentField(traceless_derivative, copy(position)),
        DependentField(D̄, copy(position)),
        DependentField(traceless_adiabatic_derivative, copy(position)),

        DependentField(centroid, copy(position)),
        DependentField(centroid_potential, copy(position)),
        DependentField(centroid_derivative, copy(position)),
        DependentField(centroid_eigen, copy(position)),
        DependentField(centroid_adiabatic_derivative, copy(position)),
        DependentField(centroid_nonadiabatic_coupling, copy(position)),

        stats
    )
end



"""
    struct: QuantumFrictionModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct QuantumFrictionModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
    derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
    eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
    adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
    nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}
    friction::DependentField{Matrix{T}, Matrix{T}}
    tmp_mat::Matrix{T}
    stats::Dict{Symbol,Int}
end

"""
    function: QuantumFrictionModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation.
"""
function QuantumFrictionModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = Hermitian(zero(mat))
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    eigen = Eigen(zero(vec), zero(mat) + I)
    adiabatic_derivative = [zero(mat) for _ in CartesianIndices(derivative)]
    nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(derivative)]
    friction = zeros(ndofs(model)*atoms, ndofs(model)*atoms)
    tmp_mat = zero(mat)

    position = fill(NaN, ndofs(model), atoms)


    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0,
        :friction=>0
    )

    return QuantumFrictionModel_Cache{T,M,n,n^2}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        DependentField(friction, copy(position)),
        tmp_mat,
        stats
    )
end



"""
    struct: RingPolymer_QuantumFrictionModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}

        traceless_potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
        V̄::DependentField{Vector{T},Array{T,3}}
        traceless_derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
        D̄::DependentField{Array{T,3},Array{T,3}}
        traceless_adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}

        centroid::DependentField{Matrix{T},Array{T,3}}
        centroid_potential::DependentField{Hermitian{T,Matrix{T}},Array{T,3}}
        centroid_derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Array{T,3}}
        centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Array{T,3}}
        centroid_adiabatic_derivative::DependentField{Matrix{Matrix{T}},Array{T,3}}
        centroid_nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Array{T,3}}

        stats::Dict{Symbol,Int}

Struct of type Abstract_QuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct RingPolymer_QuantumFrictionModel_Cache{T,M,S,L} <: Abstract_QuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{Hermitian{T,Matrix{T}}}, Array{T,3}}
    derivative::DependentField{Array{Hermitian{T,Matrix{T}},3}, Array{T,3}}
    eigen::DependentField{Vector{LinearAlgebra.Eigen{T,T,Matrix{T}, SVector{S,T}}}, Array{T,3}}
    adiabatic_derivative::DependentField{Array{Matrix{T},3}, Array{T,3}}
    nonadiabatic_coupling::DependentField{Array{Matrix{T},3}, Array{T,3}}
    friction::DependentField{Array{Matrix{T},3}, Array{T,3}}
    tmp_mat::Matrix{T}

    traceless_potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
    V̄::DependentField{Vector{T},Array{T,3}}
    traceless_derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
    D̄::DependentField{Array{T,3},Array{T,3}}
    traceless_adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}

    centroid::DependentField{Matrix{T},Array{T,3}}
    centroid_potential::DependentField{Hermitian{T,Matrix{T}},Array{T,3}}
    centroid_derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Array{T,3}}
    centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Array{T,3}}
    centroid_adiabatic_derivative::DependentField{Matrix{Matrix{T}},Array{T,3}}
    centroid_nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Array{T,3}}

    stats::Dict{Symbol,Int}
end

"""
    function: RingPolymer_QuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_QuantumFrictionModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}
    n = nstates(model)
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = [Hermitian(zero(mat)) for _=1:beads]
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    eigen = [Eigen(zero(vec), zero(mat) + I) for _=1:beads]
    nonadiabatic_coupling = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    friction = [zeros(ndofs(model)*atoms, ndofs(model)*atoms) for _=1:beads]
    tmp_mat = zero(mat)

    traceless_potential = [Hermitian(zero(mat)) for _=1:beads]
    V̄ = zeros(beads)
    traceless_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    D̄ = zeros(ndofs(model), atoms, beads)
    traceless_adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = Hermitian(zero(mat))
    centroid_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    centroid_eigen = Eigen(zero(vec), zero(mat) + I)
    centroid_adiabatic_derivative = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(centroid_derivative)]

    position = fill(NaN, ndofs(model), atoms, beads)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0,
        :friction=>0,
        :traceless_potential=>0,
        :V̄=>0,
        :traceless_derivative=>0,
        :D̄=>0,
        :traceless_adiabatic_derivative=>0,
        :centroid=>0,
        :centroid_potential=>0,
        :centroid_derivative=>0,
        :centroid_eigen=>0,
        :centroid_adiabatic_derivative=>0,
        :centroid_nonadiabatic_coupling=>0,
    )

    return RingPolymer_QuantumFrictionModel_Cache{T,M,n,n^2}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        DependentField(friction, copy(position)),
        tmp_mat,

        DependentField(traceless_potential, copy(position)),
        DependentField(V̄, copy(position)),
        DependentField(traceless_derivative, copy(position)),
        DependentField(D̄, copy(position)),
        DependentField(traceless_adiabatic_derivative, copy(position)),

        DependentField(centroid, copy(position)),
        DependentField(centroid_potential, copy(position)),
        DependentField(centroid_derivative, copy(position)),
        DependentField(centroid_eigen, copy(position)),
        DependentField(centroid_adiabatic_derivative, copy(position)),
        DependentField(centroid_nonadiabatic_coupling, copy(position)),

        stats
    )
end


#= 
"""
    struct: LargeQuantumModel_Cache{T,M,S,L} <: Abstract_LargeQuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
        derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
        eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},SVector{S,T}},Matrix{T}}
        adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
        nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}
        stats::Dict{Symbol,Int}

Struct of type Abstract_LargeQuantumModel_Cache, used to store quantities (of data types `T`, `S` and `L`) generated by its input model `M`.
"""
struct LargeQuantumModel_Cache{T,M} <: Abstract_LargeQuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Hermitian{T,Matrix{T}},Matrix{T}}
    derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Matrix{T}}
    eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}},Matrix{T}}
    adiabatic_derivative::DependentField{Matrix{Matrix{T}},Matrix{T}}
    nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Matrix{T}}
    tmp_mat::Matrix{T}
    stats::Dict{Symbol,Int}
end

"""
    function: LargeQuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}

Function which constructs and returns the Struct of the same name. Takes as input an adiabatic model `M` of the users choice
and the number of atoms in the simulation.
"""
function LargeQuantumModel_Cache{T}(model::M, atoms::Integer) where {T,M<:Model}
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = Hermitian(zero(mat))
    derivative = [Hermitian(zero(mat)) for i=1:ndofs(model), j=1:atoms]
    eigen = Eigen(zero(vec), zero(mat)+I)
    adiabatic_derivative = [zero(mat) for i=1:ndofs(model), j=1:atoms]
    nonadiabatic_coupling = [zero(mat) for i=1:ndofs(model), j=1:atoms]
    tmp_mat = zero(mat)

    position = fill(NaN, ndofs(model), atoms)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0
    )

    return LargeQuantumModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        tmp_mat,
        stats,
    )
end

"""
    struct: RingPolymer_LargeQuantumModel_Cache{T,M} <: Abstract_LargeQuantumModel_Cache{T,M}
        model::M
        potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
        derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
        eigen::DependentField{Vector{LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}},Array{T,3}}
        adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}
        nonadiabatic_coupling::DependentField{Array{Matrix{T},3},Array{T,3}}
        tmp_mat::Matrix{T}

        centroid::DependentField{Matrix{T},Array{T,3}}
        centroid_potential::DependentField{Hermitian{T,Matrix{T}},Array{T,3}}
        centroid_derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Array{T,3}}
        centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}},Array{T,3}}
        centroid_adiabatic_derivative::DependentField{Matrix{Matrix{T}},Array{T,3}}
        centroid_nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Array{T,3}}

        stats::Dict{Symbol,Int}

Struct of type Abstract_LargeQuantumModel_Cache, used to store quantities (of data types `T`) generated by its input model `M`.
"""
struct RingPolymer_LargeQuantumModel_Cache{T,M} <: Abstract_LargeQuantumModel_Cache{T,M}
    model::M
    potential::DependentField{Vector{Hermitian{T,Matrix{T}}},Array{T,3}}
    derivative::DependentField{Array{Hermitian{T,Matrix{T}},3},Array{T,3}}
    eigen::DependentField{Vector{LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}}},Array{T,3}}
    adiabatic_derivative::DependentField{Array{Matrix{T},3},Array{T,3}}
    nonadiabatic_coupling::DependentField{Array{Matrix{T},3},Array{T,3}}
    tmp_mat::Matrix{T}

    centroid::DependentField{Matrix{T},Array{T,3}}
    centroid_potential::DependentField{Hermitian{T,Matrix{T}},Array{T,3}}
    centroid_derivative::DependentField{Matrix{Hermitian{T,Matrix{T}}},Array{T,3}}
    centroid_eigen::DependentField{LinearAlgebra.Eigen{T,T,Matrix{T},Vector{T}},Array{T,3}}
    centroid_adiabatic_derivative::DependentField{Matrix{Matrix{T}},Array{T,3}}
    centroid_nonadiabatic_coupling::DependentField{Matrix{Matrix{T}},Array{T,3}}

    stats::Dict{Symbol,Int}
end

"""
    function: RingPolymer_LargeQuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}

Function which constructs and returns the struct of the same name. Takes as input an adiabatic model `M` of the users choice, 
the number of atoms in the simulation and the number of beads used in the ring polymer simulation.
"""
function RingPolymer_LargeQuantumModel_Cache{T}(model::M, atoms::Integer, beads::Integer) where {T,M<:Model}
    mat = NQCModels.QuantumModels.matrix_template(model, T)
    vec = NQCModels.QuantumModels.vector_template(model, T)

    potential = [Hermitian(zero(mat)) for _=1:beads]
    derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    eigen = [Eigen(zero(vec), zero(mat)+I) for _=1:beads]
    adiabatic_derivative = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    nonadiabatic_coupling = [zero(mat) for _=1:ndofs(model), _=1:atoms, _=1:beads]
    tmp_mat = zero(mat)

    centroid = zeros(T, ndofs(model), atoms)
    centroid_potential = Hermitian(zero(mat))
    centroid_derivative = [Hermitian(zero(mat)) for _=1:ndofs(model), _=1:atoms]
    centroid_eigen = Eigen(zero(vec), zero(mat) + I)
    centroid_adiabatic_derivative = [zero(mat) for _ in CartesianIndices(centroid_derivative)]
    centroid_nonadiabatic_coupling = [zero(mat) for _ in CartesianIndices(centroid_derivative)]

    position = fill(NaN, ndofs(model), atoms, beads)

    stats = Dict{Symbol,Int}(
        :potential=>0,
        :derivative=>0,
        :eigen=>0,
        :adiabatic_derivative=>0,
        :nonadiabatic_coupling=>0,
        :centroid=>0,
        :centroid_potential=>0,
        :centroid_derivative=>0,
        :centroid_eigen=>0,
        :centroid_adiabatic_derivative=>0,
        :centroid_nonadiabatic_coupling=>0,
    )

    return RingPolymer_LargeQuantumModel_Cache{T,M}(
        model,
        DependentField(potential, copy(position)),
        DependentField(derivative, copy(position)),
        DependentField(eigen, copy(position)),
        DependentField(adiabatic_derivative, copy(position)),
        DependentField(nonadiabatic_coupling, copy(position)),
        tmp_mat,

        DependentField(centroid, copy(position)),
        DependentField(centroid_potential, copy(position)),
        DependentField(centroid_derivative, copy(position)),
        DependentField(centroid_eigen, copy(position)),
        DependentField(centroid_adiabatic_derivative, copy(position)),
        DependentField(centroid_nonadiabatic_coupling, copy(position)),

        stats,
    )
end
=#

#Multiple dispatch definitions of the Create_Cache function with creates a Cache of the appropriate type dependent on what model type it is given
function Create_Cache(model::ClassicalModel, atoms::Integer, t::Type{T}) where {T}  #functions of this type were called Calculator(model, atoms, t)
    ClassicalModel_Cache{t}(model, atoms)
end

function Create_Cache(model::ClassicalModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_ClassicalModel_Cache{t}(model, atoms, beads)
end

function Create_Cache(model::ClassicalFrictionModel, atoms::Integer, t::Type{T}) where {T}
    Friction_Cache{t}(model, atoms)
end

function Create_Cache(model::ClassicalFrictionModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_Friction_Cache{t}(model, atoms, beads)
end

function Create_Cache(model::CompositeModel, atoms::Integer, t::Type{T}) where {T}
    if any([!isa(s.model, ClassicalModel) for s in NQCModels.get_pes_models(model.subsystems)])
        throw(ArgumentError("Currently, only CompositeModels using ClassicalModels to supply a PES are supported. "))
    end
    Friction_Cache{t}(model, atoms)
end

function Create_Cache(model::CompositeModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    if any([!isa(s.model, ClassicalModel) for s in NQCModels.get_pes_models(model.subsystems)])
        throw(ArgumentError("Currently, only CompositeModels using ClassicalModels to supply a PES are supported. "))
    end
    RingPolymer_Friction_Cache{t}(model, atoms, beads)
end

function Create_Cache(model::QuantumModel, atoms::Integer, t::Type{T}) where {T}
    QuantumModel_Cache{t}(model, atoms)
end

function Create_Cache(model::QuantumModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_QuantumModel_Cache{t}(model, atoms, beads)
end

function Create_Cache(model::QuantumFrictionModel, atoms::Integer, t::Type{T}) where {T}
    QuantumFrictionModel_Cache{t}(model, atoms)
end

function Create_Cache(model::QuantumFrictionModel, atoms::Integer, beads::Integer, t::Type{T}) where {T}
    RingPolymer_QuantumFrictionModel_Cache{t}(model, atoms, beads)
end

#= 
function Create_Cache(model::LargeQuantumModel, atoms::Integer, T::Type=Float64)
    LargeQuantumModel_Cache{T}(model, atoms)
end

function Create_Cache(model::LargeQuantumModel, atoms::Integer, beads::Integer, T::Type=Float64)
    RingPolymer_LargeQuantumModel_Cache{T}(model, atoms, beads)
end
=#